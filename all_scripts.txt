--- FILE: "C:\Users\15615\Documents\boolaka\all_scripts.txt" --- 
--- FILE: "C:\Users\15615\Documents\boolaka\all_scripts.txt" --- 

--- FILE: "C:\Users\15615\Documents\boolaka\default.project.json" --- 
{
  "name": "boolaka",
  "tree": {
    "$className": "DataModel",

    "ReplicatedStorage": {
      "Shared": {
        "$path": "src/shared"
      }
    },

    "ServerScriptService": {
      "Server": {
        "$path": "src/server"
      }
    },

    "StarterPlayer": {
      "StarterPlayerScripts": {
        "Client": {
          "$path": "src/client"
        }
      }
    },

    "Workspace": {
      "$properties": {
        "FilteringEnabled": true
      },
      "Baseplate": {
        "$className": "Part",
        "$properties": {
          "Anchored": true,
          "Color": [
            0.38823,
            0.37254,
            0.38823
          ],
          "Locked": true,
          "Position": [
            0,
            -10,
            0
          ],
          "Size": [
            512,
            20,
            512
          ]
        }
      }
    },
    "Lighting": {
      "$properties": {
        "Ambient": [
          0,
          0,
          0
        ],
        "Brightness": 2,
        "GlobalShadows": true,
        "Outlines": false,
        "Technology": "Voxel"
      }
    },
    "SoundService": {
      "$properties": {
        "RespectFilteringEnabled": true
      }
    }
  }
}
--- FILE: "C:\Users\15615\Documents\boolaka\README.md" --- 
# boolaka
Generated by [Rojo](https://github.com/rojo-rbx/rojo) 7.4.4.

## Getting Started
To build the place from scratch, use:

```bash
rojo build -o "boolaka.rbxlx"
```

Next, open `boolaka.rbxlx` in Roblox Studio and start the Rojo server:

```bash
rojo serve
```

For more help, check out [the Rojo documentation](https://rojo.space/docs).
--- FILE: "C:\Users\15615\Documents\boolaka\python\config.py" --- 
"""
This file holds the "Physics DNA" of our universe.
We will evolve these numbers.
"""

import numpy as np

class Config:
    # Matter Constants
    CHEMISTRY = {
        "BOND_DISTANCE": 5,  # How close particles must be to stick
        "DAMPING": 0.98,  # Velocity damping (friction/viscosity) - 0.98 = 2% loss per step
        # Reaction parameters (Arrhenius equation)
        "ACTIVATION_ENERGY": 50.0,  # Energy threshold for reactions (kcal/mol, scaled)
        "BOLTZMANN_TEMPERATURE": 1.0,  # Temperature factor (kT in energy units)
        "REACTION_PROBABILITY_SCALE": 0.01,  # Scaling factor for reaction probability
    }
    
    # Physics Constants
    PHYSICS = {
        "GRAVITY": np.array([0.0, -9.8]),  # A constant downward pull
    }
    
    # World Constants
    WORLD = {
        "GRID_CELL_SIZE": 10,  # The size of our lag-stopping "buckets"
        "WIDTH": 500,          # Size of the 2D "box"
        "HEIGHT": 1000,        # Size of the 2D "box"
    }
    
    # Sun Constants (Radiative Energy Source)
    # Real physics: Inverse Square Law (energy = constant / distance¬≤)
    # Solar constant: ~1361 W/m¬≤ at Earth's distance (scaled for simulation)
    SUN = {
        "POSITION": np.array([250.0, 1000.0]),  # Position of energy source (top center)
        "STRENGTH": 2000.0,                      # Radiative power (scaled for simulation units)
    }
    
    # Simulation Constants
    SEED = {
        "PLANET_PARTICLES": 1000,     # Reduced for fast testing (was 10,000)
        "ATMOSPHERE_PARTICLES": 100,  # Reduced for fast testing (was 1,000)
    }







.
--- FILE: "C:\Users\15615\Documents\boolaka\python\deep_test.py" --- 
"""
Focused Deep Testing System
Tests 3-5 promising parameter combinations with:
- 10,000 particles (more complexity)
- 300s duration (longer, deeper)
- Full molecule logging and analysis
"""

import numpy as np
from typing import Dict, List
import time
import json

from simulation_gpu import run_simulation_gpu, detect_exponential_growth
from config import Config


def run_deep_test(params: Dict, duration: float = 300.0, particles: int = 10000) -> Dict:
    """
    Run a deep test with increased particles and longer duration
    """
    original_sun_strength = Config.SUN["STRENGTH"]
    original_planet_particles = Config.SEED["PLANET_PARTICLES"]
    original_atmosphere_particles = Config.SEED["ATMOSPHERE_PARTICLES"]
    
    try:
        Config.SUN["STRENGTH"] = params["sun_strength"]
        
        # Scale particles up
        total_particles = particles
        planet_c = int(total_particles * 0.9 * params["c_ratio"] / 100)
        planet_o = int(total_particles * 0.9 * params["o_ratio"] / 100)
        atmosphere_h = int(total_particles * 0.1 * params["h_ratio"] / 100)
        
        Config.SEED["PLANET_PARTICLES"] = planet_c + planet_o
        Config.SEED["ATMOSPHERE_PARTICLES"] = atmosphere_h
        
        print(f"\nüî¨ DEEP TEST:")
        print(f"   Sun Strength: {params['sun_strength']}")
        print(f"   C:H:O Ratio: {params['c_ratio']}:{params['h_ratio']}:{params['o_ratio']}")
        print(f"   Total Particles: {particles}")
        print(f"   Duration: {duration}s")
        print(f"   Planet: {planet_c + planet_o} (C: {planet_c}, O: {planet_o})")
        print(f"   Atmosphere: {atmosphere_h} (H)")
        print()
        
        # Run simulation with full logging
        history = run_simulation_gpu(
            duration=duration,
            dt=1.0/60.0,
            log_interval=30.0,  # Log every 30s for visibility
            molecule_interval=30.0,  # Check molecules every 30s
            time_acceleration=10  # Reduced for faster iterations (was 100)
        )
        
        # Analyze for exponential growth
        all_types = set()
        for entry in history:
            all_types.update(entry.keys())
        all_types.discard("time")
        
        replicating = []
        growth_rates = {}
        for molecule_type in all_types:
            is_exp, growth_rate = detect_exponential_growth(history, molecule_type)
            growth_rates[molecule_type] = growth_rate
            if is_exp:
                replicating.append((molecule_type, growth_rate))
        
        # Get final molecule counts
        final_counts = {}
        if history:
            last_entry = history[-1]
            for key in last_entry:
                if key != "time":
                    final_counts[key] = last_entry[key]
        
        # Get molecule timeline
        molecule_timeline = []
        for entry in history:
            timeline_entry = {"time": entry.get("time", 0)}
            for key in entry:
                if key != "time":
                    timeline_entry[key] = entry[key]
            molecule_timeline.append(timeline_entry)
        
        total_molecule_types = len([k for k in all_types if k != "time"])
        total_molecules = sum(final_counts.values())
        
        # Calculate growth trends (even if not exponential)
        growth_trends = {}
        for mol_type in all_types:
            if mol_type == "time":
                continue
            counts = [entry.get(mol_type, 0) for entry in history]
            if len(counts) >= 2 and counts[-1] > 0:
                # Simple trend: final / initial
                initial = counts[0] if counts[0] > 0 else 1
                final = counts[-1]
                growth_trends[mol_type] = final / initial
        
        result = {
            "params": params,
            "particles": particles,
            "duration": duration,
            "replicating": replicating,
            "success": len(replicating) > 0,
            "final_molecule_counts": final_counts,
            "total_molecule_types": total_molecule_types,
            "total_molecules": total_molecules,
            "molecule_timeline": molecule_timeline,
            "growth_rates": growth_rates,
            "growth_trends": growth_trends
        }
        
        return result
        
    except Exception as e:
        print(f"   ‚ùå Error: {e}")
        return {
            "params": params,
            "error": str(e),
            "success": False
        }
    finally:
        Config.SUN["STRENGTH"] = original_sun_strength
        Config.SEED["PLANET_PARTICLES"] = original_planet_particles
        Config.SEED["ATMOSPHERE_PARTICLES"] = original_atmosphere_particles


def run_focused_deep_tests():
    """
    Run focused deep tests on promising parameter combinations
    """
    print("=" * 60)
    print("üî¨ FOCUSED DEEP TESTING")
    print("=" * 60)
    print()
    print("Strategy:")
    print("  - 10,000 particles (more complexity)")
    print("  - 300s duration (longer, deeper)")
    print("  - Promising parameter combinations")
    print("  - Full molecule logging and analysis")
    print()
    
    # Select promising combinations based on:
    # - Balanced ratios (need H for organic molecules)
    # - Moderate sun (not too hot, not too cold)
    # - Diversity in ratios
    promising_combinations = [
        {
            "sun_strength": 2000,
            "c_ratio": 50,
            "h_ratio": 30,
            "o_ratio": 20,
            "reason": "Balanced, moderate sun"
        },
        {
            "sun_strength": 5000,
            "c_ratio": 40,
            "h_ratio": 40,
            "o_ratio": 20,
            "reason": "High H, higher energy"
        },
        {
            "sun_strength": 1000,
            "c_ratio": 30,
            "h_ratio": 50,
            "o_ratio": 20,
            "reason": "Very high H, lower energy"
        },
        {
            "sun_strength": 2000,
            "c_ratio": 60,
            "h_ratio": 20,
            "o_ratio": 20,
            "reason": "High C, balanced"
        },
        {
            "sun_strength": 5000,
            "c_ratio": 50,
            "h_ratio": 30,
            "o_ratio": 20,
            "reason": "Balanced, high energy"
        },
    ]
    
    print(f"üìä Testing {len(promising_combinations)} promising combinations")
    print()
    
    results = []
    start_time = time.time()
    
    for i, params in enumerate(promising_combinations, 1):
        print(f"[{i}/{len(promising_combinations)}] {params['reason']}")
        
        test_start = time.time()
        result = run_deep_test(params, duration=300.0, particles=10000)
        test_time = time.time() - test_start
        
        results.append(result)
        
        # Print summary
        if result.get("success", False):
            print(f"   ‚úÖ WINNER! Replicating: {[m[0] for m in result['replicating']]}")
        else:
            print(f"   Molecules: {result.get('total_molecule_types', 0)} types, {result.get('total_molecules', 0)} total")
            if result.get("growth_trends"):
                growing = [mol for mol, trend in result["growth_trends"].items() if trend > 1.5]
                if growing:
                    print(f"   Growing molecules: {', '.join(growing)}")
        
        print(f"   Time: {test_time/60:.1f} minutes")
        print()
        
        elapsed = time.time() - start_time
        remaining = len(promising_combinations) - i
        avg_time = elapsed / i
        eta = avg_time * remaining if remaining > 0 else 0
        print(f"   ‚è±Ô∏è  Progress: {i}/{len(promising_combinations)} | Elapsed: {elapsed/60:.1f}m | ETA: {eta/60:.1f}m")
        print()
    
    total_time = time.time() - start_time
    print("=" * 60)
    print(f"‚úÖ Deep testing complete! ({total_time/60:.1f} minutes)")
    print()
    
    # Analyze results
    winners = [r for r in results if r.get("success", False)]
    
    print("üìä RESULTS:")
    print(f"   Winners (self-replication): {len(winners)}")
    print(f"   Total tests: {len(results)}")
    print()
    
    if winners:
        print("üéâ WINNING PARAMETERS:")
        print("=" * 60)
        for i, w in enumerate(winners, 1):
            p = w["params"]
            print(f"\n{i}. {p['reason']}")
            print(f"   Sun: {p['sun_strength']}, C:H:O={p['c_ratio']}:{p['h_ratio']}:{p['o_ratio']}")
            print(f"   Replicating: {[m[0] for m in w['replicating']]}")
            for mol, rate in w['replicating']:
                print(f"      - {mol}: growth rate {rate:.4f}")
    else:
        print("‚ö†Ô∏è  No self-replication detected")
        print()
        print("üìä ANALYSIS:")
        print("=" * 60)
        
        # Find which had most molecules
        results_with_molecules = [r for r in results if r.get("total_molecules", 0) > 0]
        results_with_molecules.sort(key=lambda x: x.get("total_molecules", 0), reverse=True)
        
        if results_with_molecules:
            print("\nTop combinations by molecule formation:")
            for i, r in enumerate(results_with_molecules[:3], 1):
                p = r["params"]
                total = r.get("total_molecules", 0)
                types = r.get("total_molecule_types", 0)
                counts = r.get("final_molecule_counts", {})
                trends = r.get("growth_trends", {})
                
                print(f"\n{i}. {p['reason']}")
                print(f"   Sun: {p['sun_strength']}, C:H:O={p['c_ratio']}:{p['h_ratio']}:{p['o_ratio']}")
                print(f"   Molecules: {total} total, {types} types")
                if counts:
                    top = sorted(counts.items(), key=lambda x: x[1], reverse=True)[:5]
                    print(f"   Top molecules: {', '.join([f'{mol}({count})' for mol, count in top])}")
                if trends:
                    growing = [(mol, trend) for mol, trend in trends.items() if trend > 1.2]
                    if growing:
                        print(f"   Growing: {', '.join([f'{mol}({trend:.2f}x)' for mol, trend in growing])}")
        
        print("\nüí° Next steps:")
        print("   - If no growth: LJ alone likely insufficient, consider adding chemistry")
        print("   - If some growth trends: Test those combinations even longer (600s)")
        print("   - If high molecule diversity: Test with even more particles (20k-50k)")
    
    # Save results
    with open("deep_test_results.json", "w") as f:
        json.dump({
            "winners": winners,
            "all_results": results,
            "total_tests": len(results),
            "total_time": total_time
        }, f, indent=2)
    
    print(f"\nüíæ Results saved to deep_test_results.json")
    
    return winners


if __name__ == "__main__":
    winners = run_focused_deep_tests()

.
--- FILE: "C:\Users\15615\Documents\boolaka\python\matter.py" --- 
"""
This is the "atom" of our universe.
It's a pure data structure.
"""

import numpy as np
from typing import List

# Real atomic properties (Lennard-Jones parameters + mass)
# Based on measured values from molecular dynamics simulations
ATOMIC_PROPERTIES = {
    "CARBON": {
        "epsilon": 0.105,  # kcal/mol (bond strength)
        "sigma": 3.40,     # Angstroms (atomic radius)
        "mass": 12.0,      # Atomic mass units (Carbon-12)
    },
    "HYDROGEN": {
        "epsilon": 0.022,  # Weakest bonds
        "sigma": 2.65,     # Smallest atom
        "mass": 1.0,       # Atomic mass units (Hydrogen-1)
    },
    "OXYGEN": {
        "epsilon": 0.120,  # Strong bonds
        "sigma": 3.12,     # Medium size
        "mass": 16.0,      # Atomic mass units (Oxygen-16)
    },
}

class Particle:
    """Particle class representing an atom"""
    def __init__(self, p_type: str, pos: np.ndarray):
        props = ATOMIC_PROPERTIES.get(p_type, ATOMIC_PROPERTIES["CARBON"])
        
        self.position = pos.copy()
        self.velocity = np.array([0.0, 0.0])  # Start still
        self.mass = props["mass"]
        self.particle_type = p_type
        self.epsilon = props["epsilon"]
        self.sigma = props["sigma"]
        self.bonds: List['Particle'] = []  # List of particles this particle is bonded to

def create(p_type: str, pos: np.ndarray) -> Particle:
    """Factory for making new particles"""
    return Particle(p_type, pos)

def is_bonded(particle: Particle, other: Particle) -> bool:
    """Helper function to check if particle A is bonded to particle B"""
    return other in particle.bonds

def add_bond(particle_a: Particle, particle_b: Particle):
    """Helper function to add a bond (both directions)"""
    if not is_bonded(particle_a, particle_b):
        particle_a.bonds.append(particle_b)
        particle_b.bonds.append(particle_a)

def remove_bond(particle_a: Particle, particle_b: Particle):
    """Helper function to remove a bond (both directions)"""
    if particle_b in particle_a.bonds:
        particle_a.bonds.remove(particle_b)
    if particle_a in particle_b.bonds:
        particle_b.bonds.remove(particle_a)







.
--- FILE: "C:\Users\15615\Documents\boolaka\python\parameter_sweep.py" --- 
"""
Fast Parameter Sweep System
Tests parameter combinations sequentially with early stopping
Auto-detects exponential growth and reports winners
"""

import numpy as np
from typing import Dict, List, Tuple, Optional
import time
from collections import defaultdict
import json
import copy

from simulation_gpu import run_simulation_gpu, detect_exponential_growth
from config import Config


def run_single_simulation(params: Dict, duration: float = 120.0) -> Dict:
    """
    Run a single simulation with given parameters
    Returns results dict with molecule history and parameters
    """
    # Save original config
    original_sun_strength = Config.SUN["STRENGTH"]
    original_planet_particles = Config.SEED["PLANET_PARTICLES"]
    original_atmosphere_particles = Config.SEED["ATMOSPHERE_PARTICLES"]
    
    try:
        # Set test parameters
        Config.SUN["STRENGTH"] = params["sun_strength"]
        Config.SEED["PLANET_PARTICLES"] = params["planet_particles"]
        Config.SEED["ATMOSPHERE_PARTICLES"] = params["atmosphere_particles"]
        
        print(f"   Testing: Sun={params['sun_strength']}, C:H:O={params['c_ratio']}:{params['h_ratio']}:{params['o_ratio']}")
        
        # Suppress verbose output during parameter sweep
        import sys
        from io import StringIO
        old_stdout = sys.stdout
        sys.stdout = StringIO()  # Capture output
        
        try:
            # Run simulation (shorter duration for fast testing)
            history = run_simulation_gpu(
                duration=duration,
                dt=1.0/60.0,
                log_interval=60.0,  # Less frequent logging for speed
                molecule_interval=60.0,  # Less frequent molecule detection
                time_acceleration=10  # Reduced for faster iterations (was 100)
            )
        finally:
            sys.stdout = old_stdout  # Restore output
        
        # Analyze for exponential growth
        all_types = set()
        for entry in history:
            all_types.update(entry.keys())
        all_types.discard("time")
        
        replicating = []
        for molecule_type in all_types:
            is_exp, growth_rate = detect_exponential_growth(history, molecule_type)
            if is_exp:
                replicating.append((molecule_type, growth_rate))
        
        result = {
            "params": params,
            "replicating": replicating,
            "success": len(replicating) > 0
        }
        
        if result["success"]:
            print(f"   ‚úÖ WINNER! Replicating: {[m[0] for m in replicating]}")
        
        return result
        
    except Exception as e:
        print(f"   ‚ùå Error: {e}")
        return {
            "params": params,
            "error": str(e),
            "success": False
        }
    finally:
        # Restore original config
        Config.SUN["STRENGTH"] = original_sun_strength
        Config.SEED["PLANET_PARTICLES"] = original_planet_particles
        Config.SEED["ATMOSPHERE_PARTICLES"] = original_atmosphere_particles


def generate_parameter_grid() -> List[Dict]:
    """
    Generate parameter combinations to test
    Start with focused grid around promising values
    """
    sun_strengths = [500, 1000, 2000, 5000, 10000]
    
    # Particle ratios: [C, H, O] percentages
    # Total particles = 1100, so calculate counts
    ratios = [
        (70, 0, 30),   # High C, no H, some O
        (50, 30, 20),  # Balanced
        (30, 50, 20),  # High H
        (40, 40, 20),  # C and H balanced
        (60, 20, 20),  # High C, some H
    ]
    
    # For each ratio, calculate actual particle counts
    total_particles = 1100
    param_combos = []
    
    for sun_strength in sun_strengths:
        for c_pct, h_pct, o_pct in ratios:
            planet_c = int(total_particles * 0.9 * c_pct / 100)
            planet_o = int(total_particles * 0.9 * o_pct / 100)
            atmosphere_h = int(total_particles * 0.1 * h_pct / 100)
            
            # Ensure we have at least some particles of each type
            if planet_c < 10 or planet_o < 10:
                continue
            if h_pct > 0 and atmosphere_h < 10:
                continue
            
            param_combos.append({
                "sun_strength": sun_strength,
                "planet_particles": planet_c + planet_o,
                "atmosphere_particles": atmosphere_h,
                "c_ratio": c_pct,
                "h_ratio": h_pct,
                "o_ratio": o_pct,
            })
    
    return param_combos


def run_parameter_sweep(duration: float = 120.0):
    """
    Run parameter sweep sequentially (GPU can't be shared across processes)
    """
    print("üî¨ Starting Parameter Sweep...")
    print("=" * 60)
    
    # Generate parameter combinations
    param_grid = generate_parameter_grid()
    print(f"üìä Testing {len(param_grid)} parameter combinations")
    print(f"‚è±Ô∏è  Duration per simulation: {duration}s")
    print(f"‚è±Ô∏è  Estimated total time: ~{len(param_grid) * duration / 60:.1f} minutes")
    print()
    
    # Run sequentially (GPU can't be shared across processes easily)
    results = []
    start_time = time.time()
    winners_found = 0
    
    for i, params in enumerate(param_grid, 1):
        print(f"üîÑ [{i}/{len(param_grid)}] ", end="")
        
        result = run_single_simulation(params, duration)
        results.append(result)
        
        if result.get("success", False):
            winners_found += 1
        
        elapsed = time.time() - start_time
        remaining = len(param_grid) - i
        avg_time = elapsed / i
        eta = avg_time * remaining if i > 0 else 0
        print(f"   ‚è±Ô∏è  Progress: {i}/{len(param_grid)} | Elapsed: {elapsed:.1f}s | ETA: {eta:.1f}s")
        print()
    
    total_time = time.time() - start_time
    print("=" * 60)
    print(f"‚úÖ Parameter sweep complete! ({total_time/60:.1f} minutes)")
    print()
    
    # Analyze results
    winners = [r for r in results if r.get("success", False)]
    errors = [r for r in results if "error" in r]
    
    print("üìä RESULTS:")
    print(f"   Total tests: {len(results)}")
    print(f"   Winners (self-replication detected): {len(winners)}")
    print(f"   Errors: {len(errors)}")
    print()
    
    if winners:
        print("üéâ WINNING PARAMETERS:")
        print("=" * 60)
        for i, w in enumerate(winners, 1):
            p = w["params"]
            print(f"\n{i}. Replicating molecules: {[m[0] for m in w['replicating']]}")
            print(f"   Sun Strength: {p['sun_strength']}")
            print(f"   C:H:O Ratio: {p['c_ratio']}:{p['h_ratio']}:{p['o_ratio']}")
            print(f"   Planet Particles: {p['planet_particles']}")
            print(f"   Atmosphere Particles: {p['atmosphere_particles']}")
            for mol, rate in w['replicating']:
                print(f"      - {mol}: growth rate {rate:.4f}")
    else:
        print("‚ö†Ô∏è  No self-replication detected in this sweep")
        print("   Next steps:")
        print("   - Try different parameter ranges")
        print("   - Increase simulation duration to 300s")
        print("   - Test more particle diversity")
        print("   - Adjust sun position/strength gradients")
    
    # Save results
    with open("parameter_sweep_results.json", "w") as f:
        json.dump({
            "winners": winners,
            "all_results": results,
            "total_tests": len(results),
            "total_time": total_time
        }, f, indent=2)
    
    print(f"\nüíæ Results saved to parameter_sweep_results.json")
    
    return winners


if __name__ == "__main__":
    # Run parameter sweep
    # GPU can't be shared across processes, so we run sequentially
    # But each simulation is fast (120s = 2 minutes with GPU acceleration)
    winners = run_parameter_sweep(
        duration=120.0   # 2 minutes per simulation (fast test)
    )

.
--- FILE: "C:\Users\15615\Documents\boolaka\python\physics_kernel.py" --- 
"""
THE SINGULAR LAW: Lennard-Jones Potential
This ONE function replaces Collide(), Bond(), and ApplyBondConstraints()
It models the actual electromagnetic force between atoms
"""

import numpy as np
from matter import Particle
from config import Config

def apply_atomic_force(particle_a: Particle, particle_b: Particle):
    """
    THE SINGULAR LAW: ApplyAtomicForce
    This ONE function REPLACES Collide(), Bond(), and ApplyBondConstraints().
    It calculates the REAL electromagnetic force between two particles.
    """
    # 1. Get the vector and distance between them
    diff = particle_b.position - particle_a.position
    distance = np.linalg.norm(diff)
    
    # Optimization: If they are too far apart, don't bother.
    # This "cutoff" distance saves 99% of our CPU.
    if distance > Config.CHEMISTRY["BOND_DISTANCE"] or distance == 0:
        return
    
    # ### THE LENNARD-JONES MATH (The God Formula) ###
    # Use Lorentz-Berthelot mixing rules for different atom types
    # This is how real molecular dynamics handles different atoms
    epsilon = np.sqrt(particle_a.epsilon * particle_b.epsilon)  # Geometric mean
    sigma = (particle_a.sigma + particle_b.sigma) / 2  # Arithmetic mean
    
    # 1. (SIGMA / distance)^6  -> This is the ATTRACTION force (pulls them together)
    # 2. (SIGMA / distance)^12 -> This is the REPULSION force (shoves them apart)
    term = sigma / distance
    
    # We calculate the attraction (to the 6th power)
    attraction = term ** 6
    
    # We calculate the repulsion (to the 12th power)
    # Because it's to the 12th, it's MUCH stronger at close range.
    repulsion = term ** 12
    
    # The total force = (Repulsion - Attraction)
    # We multiply by 4 * Epsilon to get the right strength
    force_magnitude = 4 * epsilon * (repulsion - attraction)
    
    # ### END OF MATH ###
    
    # Now we apply that force to both particles
    # We get the direction (normalized diff) and multiply by the strength (force_magnitude)
    if distance > 0:
        normal = diff / distance
        force_vector = force_magnitude * normal
        
        # We push/pull both particles based on this one, true force.
        # Newton's 3rd law: equal and opposite forces
        particle_a.velocity -= force_vector
        particle_b.velocity += force_vector

def move(particle: Particle, dt: float):
    """
    LAW 2: MOVEMENT (Gravity + Radiative Heating + Damping)
    """
    # Apply gravity (constant pull down)
    particle.velocity += Config.PHYSICS["GRAVITY"] * dt
    
    # Apply radiative heating (Inverse Square Law)
    # Real physics: Energy received = SUN_STRENGTH / (distance¬≤)
    sun_diff = Config.SUN["POSITION"] - particle.position
    sun_distance = np.linalg.norm(sun_diff)
    
    # Prevent singularity at distance = 0
    if sun_distance > 0.1:
        # Inverse square law: energy = strength / distance¬≤
        energy_received = Config.SUN["STRENGTH"] / (sun_distance * sun_distance)
        
        # Convert energy to kinetic energy: KE = 0.5 * m * v¬≤
        # So: v = sqrt(2 * KE / m)
        # We add this as a velocity impulse in the direction away from the sun
        velocity_impulse = np.sqrt(2 * energy_received / particle.mass) * dt
        if sun_distance > 0:
            sun_direction = sun_diff / sun_distance
            particle.velocity += sun_direction * velocity_impulse
    
    # Apply damping (friction/viscosity) - REAL PHYSICS
    # Velocity decays exponentially: v = v * damping_factor
    particle.velocity *= Config.CHEMISTRY["DAMPING"]
    
    # Update position
    particle.position += particle.velocity * dt







.
--- FILE: "C:\Users\15615\Documents\boolaka\python\simulation.py" --- 
"""
Main simulation loop - ported from boot.server.luau
Runs fast simulations to detect self-replication
"""

import numpy as np
import random
import time
from typing import List, Dict, Tuple
from collections import defaultdict

from config import Config
from matter import Particle, create, is_bonded, add_bond, remove_bond
from physics_kernel import apply_atomic_force, move
from spatial_hash_grid import SpatialHashGrid

# Set random seed for reproducibility (ensures 1:1 with Roblox if same seed)
random.seed(42)
np.random.seed(42)

def find_molecules(particles: List[Particle]) -> List[List[Particle]]:
    """Find all molecules (connected components via bonds)"""
    molecules = []
    visited = set()
    
    def dfs(particle: Particle, molecule: List[Particle]):
        """DFS to find all particles in a molecule"""
        if particle in visited:
            return
        visited.add(particle)
        molecule.append(particle)
        
        # Visit all bonded particles
        for bonded in particle.bonds:
            dfs(bonded, molecule)
    
    # Find all molecules
    for particle in particles:
        if particle not in visited and len(particle.bonds) > 0:
            # Only count particles that have bonds (molecules, not isolated atoms)
            molecule = []
            dfs(particle, molecule)
            if len(molecule) > 1:  # Only molecules with 2+ atoms
                molecules.append(molecule)
    
    return molecules

def identify_molecule(molecule: List[Particle]) -> str:
    """Identify molecular patterns"""
    carbon_count = 0
    hydrogen_count = 0
    oxygen_count = 0
    
    for particle in molecule:
        if particle.particle_type == "CARBON":
            carbon_count += 1
        elif particle.particle_type == "HYDROGEN":
            hydrogen_count += 1
        elif particle.particle_type == "OXYGEN":
            oxygen_count += 1
    
    # Match to known patterns
    if carbon_count == 1 and hydrogen_count == 4:
        return "CH4"
    elif carbon_count == 1 and oxygen_count == 2:
        return "CO2"
    elif carbon_count == 1 and hydrogen_count == 2 and oxygen_count == 1:
        return "H2CO"
    elif hydrogen_count == 2 and oxygen_count == 1:
        return "H2O"
    elif hydrogen_count == 2:
        return "H2"
    elif oxygen_count == 2:
        return "O2"
    elif carbon_count == 1 and oxygen_count == 1:
        return "CO"
    elif carbon_count > 0 or hydrogen_count > 0 or oxygen_count > 0:
        # Unknown pattern, return formula
        formula = ""
        if carbon_count > 0:
            formula += f"C{carbon_count if carbon_count > 1 else ''}"
        if hydrogen_count > 0:
            formula += f"H{hydrogen_count if hydrogen_count > 1 else ''}"
        if oxygen_count > 0:
            formula += f"O{oxygen_count if oxygen_count > 1 else ''}"
        return formula
    else:
        return "UNKNOWN"

def detect_exponential_growth(molecule_history: List[Dict[str, int]], molecule_type: str) -> Tuple[bool, float]:
    """
    Detect if a molecule type shows exponential growth
    Returns: (is_exponential, growth_rate)
    """
    if len(molecule_history) < 5:
        return False, 0.0
    
    # Extract counts over time
    times = []
    counts = []
    for entry in molecule_history:
        times.append(entry["time"])
        counts.append(entry.get(molecule_type, 0))
    
    # Filter out zeros (can't fit exponential to zeros)
    if all(c == 0 for c in counts):
        return False, 0.0
    
    # Fit exponential: count = a * e^(r * t)
    # Linearize: ln(count) = ln(a) + r * t
    times = np.array(times)
    counts = np.array(counts)
    
    # Only fit to non-zero values
    mask = counts > 0
    if np.sum(mask) < 3:
        return False, 0.0
    
    times_fit = times[mask]
    counts_fit = counts[mask]
    log_counts = np.log(counts_fit + 1e-10)  # Add small epsilon to avoid log(0)
    
    # Linear fit: log(count) = a + r * t
    if len(times_fit) > 1:
        coeffs = np.polyfit(times_fit, log_counts, 1)
        growth_rate = coeffs[0]
        
        # Calculate R¬≤
        predicted = np.polyval(coeffs, times_fit)
        ss_res = np.sum((log_counts - predicted) ** 2)
        ss_tot = np.sum((log_counts - np.mean(log_counts)) ** 2)
        r_squared = 1 - (ss_res / (ss_tot + 1e-10))
        
        # Exponential if R¬≤ > 0.8 and growth rate > 0.01
        is_exponential = r_squared > 0.8 and growth_rate > 0.01
        
        return is_exponential, growth_rate
    
    return False, 0.0

def run_simulation(duration: float = 600.0, dt: float = 1.0/60.0, log_interval: float = 1.0, molecule_interval: float = 5.0, time_acceleration: int = 10):
    """
    Run the simulation for a specified duration
    Args:
        duration: Simulation time in seconds
        dt: Time step (default 1/60s)
        log_interval: How often to log bonds (seconds)
        molecule_interval: How often to detect molecules (seconds)
        time_acceleration: Run N physics steps per iteration (10x = 10 steps per iteration)
    Returns: molecule_history (list of molecule counts over time)
    """
    print("üåå Creating Universe...")
    
    all_particles: List[Particle] = []
    grid = SpatialHashGrid(Config.WORLD["GRID_CELL_SIZE"])
    
    # Seed the "PLANET" (The Primordial Soup)
    print("üåç Seeding Planet...")
    for i in range(Config.SEED["PLANET_PARTICLES"]):
        # Spawn in a dense clump at the bottom
        pos = np.array([
            random.uniform(0, Config.WORLD["WIDTH"]),
            random.uniform(0, Config.WORLD["HEIGHT"] / 4)  # Only in bottom 25%
        ])
        
        # 70% Carbon, 30% Oxygen
        p_type = "CARBON" if random.random() < 0.7 else "OXYGEN"
        p = create(p_type, pos)
        all_particles.append(p)
    
    # Seed the "ATMOSPHERE" (The Fuel)
    print("üí® Seeding Atmosphere...")
    for i in range(Config.SEED["ATMOSPHERE_PARTICLES"]):
        # Spawn in a thin gas at the top
        pos = np.array([
            random.uniform(0, Config.WORLD["WIDTH"]),
            random.uniform(Config.WORLD["HEIGHT"] / 2, Config.WORLD["HEIGHT"])  # Only in top 50%
        ])
        
        p = create("HYDROGEN", pos)
        all_particles.append(p)
    
    print("üî• IGNITION. Starting Physics Loop...")
    
    # Tracking
    molecule_history = []
    current_time = 0.0
    last_log_time = 0.0
    last_molecule_time = 0.0
    bond_update_counter = 0  # Update bonds every N iterations
    
    start_time = time.time()
    
    # Cap dt to prevent physics explosions
    actual_dt = min(dt, 0.1)
    
    # Main loop with time acceleration
    while current_time < duration:
        # Run multiple physics steps per iteration (time acceleration)
        for _ in range(time_acceleration):
            if current_time >= duration:
                break
            
            # Clear grid
            grid.clear()
            
            # Insert phase
            for p in all_particles:
                grid.insert(p)
            
            # Physics phase - process all particles
            for p in all_particles:
                # Find all neighbors
                neighbors = grid.query(p.position)
                
                # Interact with neighbors
                neighbor_count = 0
                for neighbor in neighbors:
                    if p is neighbor:
                        continue  # Don't check against self
                    if neighbor_count >= 20:
                        break  # Limit neighbors per particle
                    
                    # Apply the Lennard-Jones force (pure physics)
                    apply_atomic_force(p, neighbor)
                    neighbor_count += 1
                
                # Apply universal laws
                move(p, actual_dt)
                
                # Check boundaries (simple "box" collision) - optimized inline
                if p.position[0] < 0:
                    p.velocity[0] = -p.velocity[0]
                    p.position[0] = 0
                elif p.position[0] > Config.WORLD["WIDTH"]:
                    p.velocity[0] = -p.velocity[0]
                    p.position[0] = Config.WORLD["WIDTH"]
                
                if p.position[1] < 0:
                    p.velocity[1] = -p.velocity[1]
                    p.position[1] = 0
                elif p.position[1] > Config.WORLD["HEIGHT"]:
                    p.velocity[1] = -p.velocity[1]
                    p.position[1] = Config.WORLD["HEIGHT"]
            
            current_time += actual_dt
        
        # Bond tracking (update less frequently for performance)
        bond_update_counter += 1
        if bond_update_counter >= 3:  # Update bonds every 3 iterations
            bond_update_counter = 0
            for p in all_particles:
                neighbors = grid.query(p.position)
                for neighbor in neighbors:
                    if p is neighbor:
                        continue
                    
                    # Track bonds (just metadata - bonds form from physics above)
                    diff = neighbor.position - p.position
                    distance = np.linalg.norm(diff)
                    
                    # Calculate equilibrium distance (average sigma)
                    equilibrium_dist = (p.sigma + neighbor.sigma) / 2
                    bond_threshold = equilibrium_dist * 1.2  # Allow 20% tolerance for movement
                    
                    # Check relative velocity (stable if moving together, not apart)
                    relative_vel = neighbor.velocity - p.velocity
                    relative_speed = np.linalg.norm(relative_vel)
                    
                    # Bond if: within equilibrium distance AND stable (low relative velocity)
                    if distance <= bond_threshold and relative_speed < 1.5:
                        if not is_bonded(p, neighbor):
                            add_bond(p, neighbor)
                    else:
                        # Unbond if: too far apart OR moving apart too fast
                        if distance > bond_threshold * 1.5 or relative_speed > 3.0:
                            if is_bonded(p, neighbor):
                                remove_bond(p, neighbor)
        
        # Logging phase (bonds)
        if current_time - last_log_time >= log_interval:
            total_bonds = sum(len(p.bonds) for p in all_particles)
            actual_bonds = total_bonds / 2  # Each bond counted twice
            
            print(f"‚è±Ô∏è  Time: {current_time:.1f}s | Particles: {len(all_particles)} | Bonds: {actual_bonds:.0f}")
            last_log_time = current_time
        
        # Molecular detection phase
        if current_time - last_molecule_time >= molecule_interval:
            molecules = find_molecules(all_particles)
            
            # Count molecules by type
            molecule_counts = defaultdict(int)
            for molecule in molecules:
                pattern = identify_molecule(molecule)
                molecule_counts[pattern] += 1
            
            # Store in history
            history_entry = {"time": current_time, **molecule_counts}
            molecule_history.append(history_entry)
            
            # Log results
            if molecule_counts:
                log_parts = [f"{pattern}: {count}" for pattern, count in sorted(molecule_counts.items())]
                print(f"üß™ Molecules detected: {', '.join(log_parts)}")
            else:
                print("üß™ No molecules detected (only isolated atoms)")
            
            last_molecule_time = current_time
    
    elapsed = time.time() - start_time
    print(f"\n‚úÖ Simulation complete! Ran {current_time:.1f}s simulation in {elapsed:.1f}s real time")
    print(f"   Speedup: {current_time / elapsed:.1f}x")
    
    return molecule_history

def analyze_results(molecule_history: List[Dict[str, int]]):
    """Analyze results to find replicating molecules"""
    if not molecule_history:
        print("No molecule history to analyze")
        return
    
    # Get all molecule types
    all_types = set()
    for entry in molecule_history:
        all_types.update(entry.keys())
    all_types.discard("time")
    
    print("\nüìä Analyzing for self-replication...")
    print("=" * 60)
    
    replicating = []
    for molecule_type in sorted(all_types):
        is_exp, growth_rate = detect_exponential_growth(molecule_history, molecule_type)
        if is_exp:
            replicating.append((molecule_type, growth_rate))
            print(f"‚úÖ {molecule_type}: EXPONENTIAL GROWTH (rate: {growth_rate:.4f})")
        else:
            print(f"‚ùå {molecule_type}: No exponential growth")
    
    if replicating:
        print("\nüéâ SELF-REPLICATION DETECTED!")
        print(f"   Replicating molecules: {[m[0] for m in replicating]}")
    else:
        print("\n‚ö†Ô∏è  No self-replication detected")
        print("   Try different parameters or run longer simulation")

if __name__ == "__main__":
    # Run simulation with optimizations
    # time_acceleration=10 means simulation runs 10x faster
    history = run_simulation(
        duration=600.0,  # 10 minutes simulation time
        time_acceleration=10  # Run 10 physics steps per iteration (10x faster)
    )
    
    # Analyze results
    analyze_results(history)

.
--- FILE: "C:\Users\15615\Documents\boolaka\python\simulation_gpu.py" --- 
"""
GPU-accelerated simulation using CuPy
Runs on NVIDIA GPU (RTX 4080 Ti) for massive speedup
"""

import cupy as cp  # GPU-accelerated NumPy
import numpy as np  # For CPU operations when needed
import random
import time
import math
from typing import List, Dict, Tuple
from collections import defaultdict

from config import Config
from matter import Particle, create, is_bonded, add_bond, remove_bond
from spatial_hash_grid import SpatialHashGrid

# Set random seed for reproducibility
random.seed(42)
np.random.seed(42)
cp.random.seed(42)

# Check GPU availability
try:
    mempool = cp.get_default_memory_pool()
    print(f"‚úÖ GPU detected: {cp.cuda.Device().compute_capability}")
    print(f"   GPU Memory: {cp.cuda.Device().mem_info[1] / 1e9:.2f} GB")
except:
    print("‚ùå No GPU detected. Falling back to CPU.")
    cp = np  # Fallback to NumPy

def find_molecules(particles: List[Particle]) -> List[List[Particle]]:
    """Find all molecules (connected components via bonds)"""
    molecules = []
    visited = set()
    
    def dfs(particle: Particle, molecule: List[Particle]):
        """DFS to find all particles in a molecule"""
        if particle in visited:
            return
        visited.add(particle)
        molecule.append(particle)
        
        # Visit all bonded particles
        for bonded in particle.bonds:
            dfs(bonded, molecule)
    
    # Find all molecules
    for particle in particles:
        if particle not in visited and len(particle.bonds) > 0:
            # Only count particles that have bonds (molecules, not isolated atoms)
            molecule = []
            dfs(particle, molecule)
            if len(molecule) > 1:  # Only molecules with 2+ atoms
                molecules.append(molecule)
    
    return molecules

def identify_molecule(molecule: List[Particle]) -> str:
    """Identify molecular patterns"""
    carbon_count = 0
    hydrogen_count = 0
    oxygen_count = 0
    
    for particle in molecule:
        if particle.particle_type == "CARBON":
            carbon_count += 1
        elif particle.particle_type == "HYDROGEN":
            hydrogen_count += 1
        elif particle.particle_type == "OXYGEN":
            oxygen_count += 1
    
    # Match to known patterns
    if carbon_count == 1 and hydrogen_count == 4:
        return "CH4"
    elif carbon_count == 1 and oxygen_count == 2:
        return "CO2"
    elif carbon_count == 1 and hydrogen_count == 2 and oxygen_count == 1:
        return "H2CO"
    elif hydrogen_count == 2 and oxygen_count == 1:
        return "H2O"
    elif hydrogen_count == 2:
        return "H2"
    elif oxygen_count == 2:
        return "O2"
    elif carbon_count == 1 and oxygen_count == 1:
        return "CO"
    elif carbon_count > 0 or hydrogen_count > 0 or oxygen_count > 0:
        # Unknown pattern, return formula
        formula = ""
        if carbon_count > 0:
            formula += f"C{carbon_count if carbon_count > 1 else ''}"
        if hydrogen_count > 0:
            formula += f"H{hydrogen_count if hydrogen_count > 1 else ''}"
        if oxygen_count > 0:
            formula += f"O{oxygen_count if oxygen_count > 1 else ''}"
        return formula
    else:
        return "UNKNOWN"

def compute_forces_gpu(positions_gpu, velocities_gpu, masses_gpu, epsilons_gpu, sigmas_gpu, 
                       bond_distance: float, dt: float):
    """
    GPU-accelerated force computation using batched operations
    Computes Lennard-Jones forces for all particle pairs
    OPTIMIZED: Uses squared distances for early cutoff
    """
    n = positions_gpu.shape[0]
    
    # Expand dimensions for broadcasting: (n, 1, 2) - (1, n, 2) = (n, n, 2)
    pos_i = positions_gpu[:, cp.newaxis, :]  # (n, 1, 2)
    pos_j = positions_gpu[cp.newaxis, :, :]  # (1, n, 2)
    
    # Compute all pairwise differences and SQUARED distances (faster than norm)
    diffs = pos_j - pos_i  # (n, n, 2)
    distances_sq = cp.sum(diffs ** 2, axis=2)  # (n, n) - squared distances
    distances = cp.sqrt(distances_sq + 1e-10)  # (n, n) - actual distances
    
    # Early cutoff using squared distance (faster)
    bond_distance_sq = bond_distance * bond_distance
    mask = (distances_sq > 1e-10) & (distances_sq <= bond_distance_sq)
    
    # Lorentz-Berthelot mixing rules for epsilon and sigma
    epsilon_i = epsilons_gpu[:, cp.newaxis]  # (n, 1)
    epsilon_j = epsilons_gpu[cp.newaxis, :]  # (1, n)
    epsilon_mix = cp.sqrt(epsilon_i * epsilon_j)  # (n, n)
    
    sigma_i = sigmas_gpu[:, cp.newaxis]  # (n, 1)
    sigma_j = sigmas_gpu[cp.newaxis, :]  # (1, n)
    sigma_mix = (sigma_i + sigma_j) / 2  # (n, n)
    
    # Lennard-Jones potential (only compute where mask is True)
    term = cp.where(mask, sigma_mix / (distances + 1e-10), 0)
    attraction = term ** 6
    repulsion = term ** 12
    force_magnitude = cp.where(mask, 4 * epsilon_mix * (repulsion - attraction), 0)
    
    # Normalize direction vectors
    normals = cp.where(
        (distances > 1e-10)[:, :, cp.newaxis],
        diffs / (distances[:, :, cp.newaxis] + 1e-10),
        0
    )
    
    # Force vectors: (n, n, 2) - only where mask is True
    force_vectors = force_magnitude[:, :, cp.newaxis] * normals
    
    # Sum forces on each particle (Newton's 3rd law: equal and opposite)
    # For particle i, sum all forces from j: sum over j axis
    total_forces = cp.sum(force_vectors, axis=1)  # (n, 2)
    
    # Check for NaN/Inf and replace with 0
    total_forces = cp.where(cp.isfinite(total_forces), total_forces, 0)
    
    # Update velocities
    # F = ma, so a = F/m, v += a * dt
    accelerations = total_forces / (masses_gpu[:, cp.newaxis] + 1e-10)
    velocities_gpu += accelerations * dt
    
    # Check for NaN/Inf in velocities and clamp
    velocities_gpu = cp.where(cp.isfinite(velocities_gpu), velocities_gpu, 0)
    
    return velocities_gpu

def apply_gravity_and_sun_gpu(positions_gpu, velocities_gpu, masses_gpu, dt: float):
    """Apply gravity and radiative heating on GPU"""
    n = positions_gpu.shape[0]
    
    # Gravity (constant for all particles)
    gravity = cp.array(Config.PHYSICS["GRAVITY"], dtype=cp.float32)
    velocities_gpu += gravity * dt
    
    # Radiative heating (inverse square law)
    sun_pos = cp.array(Config.SUN["POSITION"], dtype=cp.float32)
    sun_strength = Config.SUN["STRENGTH"]
    
    # Distance to sun for all particles
    sun_diffs = sun_pos - positions_gpu  # (n, 2)
    sun_distances = cp.linalg.norm(sun_diffs, axis=1)  # (n,)
    
    # Energy received (inverse square law)
    mask = sun_distances > 0.1
    energy_received = cp.where(
        mask,
        sun_strength / (sun_distances ** 2 + 1e-10),
        0
    )
    
    # Velocity impulse
    velocity_impulse = cp.sqrt(cp.maximum(2 * energy_received / (masses_gpu + 1e-10), 0)) * dt
    sun_directions = cp.where(
        (sun_distances > 1e-10)[:, cp.newaxis],
        sun_diffs / (sun_distances[:, cp.newaxis] + 1e-10),
        0
    )
    
    velocities_gpu += sun_directions * velocity_impulse[:, cp.newaxis]
    
    # Apply damping (friction/viscosity) - REAL PHYSICS
    damping = Config.CHEMISTRY["DAMPING"]
    velocities_gpu *= damping
    
    # Check for NaN/Inf and clamp
    velocities_gpu = cp.where(cp.isfinite(velocities_gpu), velocities_gpu, 0)
    
    return velocities_gpu

def update_positions_gpu(positions_gpu, velocities_gpu, dt: float):
    """Update positions on GPU"""
    positions_gpu += velocities_gpu * dt
    # Check for NaN/Inf and clamp to valid range
    positions_gpu = cp.where(cp.isfinite(positions_gpu), positions_gpu, 0)
    return positions_gpu

def apply_boundaries_gpu(positions_gpu, velocities_gpu):
    """Apply boundary conditions on GPU"""
    width = Config.WORLD["WIDTH"]
    height = Config.WORLD["HEIGHT"]
    
    # X boundaries
    x_mask_left = positions_gpu[:, 0] < 0
    x_mask_right = positions_gpu[:, 0] > width
    velocities_gpu[x_mask_left, 0] *= -1
    velocities_gpu[x_mask_right, 0] *= -1
    positions_gpu[:, 0] = cp.clip(positions_gpu[:, 0], 0, width)
    
    # Y boundaries
    y_mask_bottom = positions_gpu[:, 1] < 0
    y_mask_top = positions_gpu[:, 1] > height
    velocities_gpu[y_mask_bottom, 1] *= -1
    velocities_gpu[y_mask_top, 1] *= -1
    positions_gpu[:, 1] = cp.clip(positions_gpu[:, 1], 0, height)
    
    return positions_gpu, velocities_gpu

def run_simulation_gpu(duration: float = 600.0, dt: float = 1.0/60.0, 
                       log_interval: float = 1.0, molecule_interval: float = 5.0,
                       time_acceleration: int = 10):
    """
    Run GPU-accelerated simulation
    """
    print("üåå Creating Universe...")
    
    all_particles: List[Particle] = []
    
    # Seed particles
    print("üåç Seeding Planet...")
    for i in range(Config.SEED["PLANET_PARTICLES"]):
        pos = np.array([
            random.uniform(0, Config.WORLD["WIDTH"]),
            random.uniform(0, Config.WORLD["HEIGHT"] / 4)
        ])
        p_type = "CARBON" if random.random() < 0.7 else "OXYGEN"
        p = create(p_type, pos)
        all_particles.append(p)
    
    print("üí® Seeding Atmosphere...")
    for i in range(Config.SEED["ATMOSPHERE_PARTICLES"]):
        pos = np.array([
            random.uniform(0, Config.WORLD["WIDTH"]),
            random.uniform(Config.WORLD["HEIGHT"] / 2, Config.WORLD["HEIGHT"])
        ])
        p = create("HYDROGEN", pos)
        all_particles.append(p)
    
    print("üî• IGNITION. Starting GPU Physics Loop...")
    
    # Convert to GPU arrays
    n = len(all_particles)
    print(f"   üìä Particles: {n} | Allocating GPU arrays...")
    
    positions_gpu = cp.array([p.position for p in all_particles], dtype=cp.float32)
    velocities_gpu = cp.array([p.velocity for p in all_particles], dtype=cp.float32)
    masses_gpu = cp.array([p.mass for p in all_particles], dtype=cp.float32)
    epsilons_gpu = cp.array([p.epsilon for p in all_particles], dtype=cp.float32)
    sigmas_gpu = cp.array([p.sigma for p in all_particles], dtype=cp.float32)
    
    print("   ‚úÖ GPU arrays ready. Starting physics...")
    print("   ‚ö†Ô∏è  First iteration may take 2-5 minutes (GPU kernel compilation + 10k particles)")
    
    # Tracking
    molecule_history = []
    current_time = 0.0
    last_log_time = 0.0
    last_molecule_time = 0.0
    iteration = 0
    
    start_time = time.time()
    actual_dt = min(dt, 0.1)
    
    # Main loop
    while current_time < duration:
        iteration += 1
        
        # First iteration message
        if iteration == 1:
            print("   üöÄ Computing first physics step (this may take 2-5 minutes with 10k particles)...")
            first_step_start = time.time()
        
        for _ in range(time_acceleration):
            if current_time >= duration:
                break
            
            # GPU physics
            velocities_gpu = compute_forces_gpu(
                positions_gpu, velocities_gpu, masses_gpu, 
                epsilons_gpu, sigmas_gpu, 
                Config.CHEMISTRY["BOND_DISTANCE"], actual_dt
            )
            
            velocities_gpu = apply_gravity_and_sun_gpu(
                positions_gpu, velocities_gpu, masses_gpu, actual_dt
            )
            
            positions_gpu = update_positions_gpu(positions_gpu, velocities_gpu, actual_dt)
            positions_gpu, velocities_gpu = apply_boundaries_gpu(positions_gpu, velocities_gpu)
            
            current_time += actual_dt
        
        # Sync GPU to CPU for bond tracking (every outer iteration to match Roblox frequency)
        # Copy back to CPU for bond tracking
        positions_cpu = cp.asnumpy(positions_gpu)
        velocities_cpu = cp.asnumpy(velocities_gpu)
        
        # Safety check: Replace any NaN/Inf with 0
        positions_cpu = np.where(np.isfinite(positions_cpu), positions_cpu, 0)
        velocities_cpu = np.where(np.isfinite(velocities_cpu), velocities_cpu, 0)
        
        # Update particle objects
        for i, p in enumerate(all_particles):
            p.position = positions_cpu[i]
            p.velocity = velocities_cpu[i]
        
        # Update bonds (CPU operation) - matches Roblox logic exactly
        grid = SpatialHashGrid(Config.WORLD["GRID_CELL_SIZE"])
        for p in all_particles:
            grid.insert(p)
        
        for p in all_particles:
            neighbors = grid.query(p.position)
            for neighbor in neighbors:
                if p is neighbor:
                    continue
                
                diff = neighbor.position - p.position
                distance = np.linalg.norm(diff)
                equilibrium_dist = (p.sigma + neighbor.sigma) / 2
                bond_threshold = equilibrium_dist * 1.2  # 20% tolerance (matches Roblox)
                
                relative_vel = neighbor.velocity - p.velocity
                relative_speed = np.linalg.norm(relative_vel)
                
                # Calculate collision energy (for Arrhenius reactions)
                # KE = 0.5 * m_reduced * v_relative¬≤
                reduced_mass = (p.mass * neighbor.mass) / (p.mass + neighbor.mass + 1e-10)
                collision_energy = 0.5 * reduced_mass * (relative_speed ** 2)
                
                # STOCHASTIC REACTIONS (Arrhenius equation)
                # Real chemistry: reactions happen probabilistically based on collision energy
                activation_energy = Config.CHEMISTRY["ACTIVATION_ENERGY"]
                kT = Config.CHEMISTRY["BOLTZMANN_TEMPERATURE"]
                reaction_prob_scale = Config.CHEMISTRY["REACTION_PROBABILITY_SCALE"]
                
                # Arrhenius probability: p = scale * exp(-Ea / (E_collision + kT))
                # Higher collision energy = higher reaction probability
                if collision_energy > 0.1:  # Only consider significant collisions
                    arrhenius_prob = reaction_prob_scale * np.exp(-activation_energy / (collision_energy + kT))
                    should_react = random.random() < arrhenius_prob
                else:
                    should_react = False
                
                # Bond formation: within equilibrium distance AND (stable OR high-energy collision)
                if distance <= bond_threshold:
                    if relative_speed < 1.5 or should_react:
                        if not is_bonded(p, neighbor):
                            add_bond(p, neighbor)
                else:
                    # Bond breaking: too far apart OR high-energy collision (reaction)
                    if distance > bond_threshold * 1.5 or (relative_speed > 3.0 and should_react):
                        if is_bonded(p, neighbor):
                            remove_bond(p, neighbor)
        
        # Copy back to GPU
        positions_gpu = cp.array([p.position for p in all_particles], dtype=cp.float32)
        velocities_gpu = cp.array([p.velocity for p in all_particles], dtype=cp.float32)
        
        # Show when first iteration completes
        if iteration == 1:
            first_step_time = time.time() - first_step_start
            print(f"   ‚úÖ First step complete! ({first_step_time/60:.1f}m) | Subsequent steps will be faster")
        
        # Progress log every 5 iterations (so you see it's working)
        if iteration % 5 == 0:
            elapsed_real = time.time() - start_time
            progress_pct = (current_time / duration) * 100
            print(f"   üîÑ Iter {iteration} | Sim: {current_time:.1f}s/{duration:.0f}s ({progress_pct:.1f}%) | Real: {elapsed_real/60:.1f}m")
        
        # Logging
        if current_time - last_log_time >= log_interval:
            total_bonds = sum(len(p.bonds) for p in all_particles)
            actual_bonds = total_bonds / 2
            
            total_bonds = sum(len(p.bonds) for p in all_particles)
            actual_bonds = total_bonds / 2
            
            print(f"‚è±Ô∏è  Time: {current_time:.1f}s | Particles: {n} | Bonds: {actual_bonds:.0f}")
            last_log_time = current_time
        
        # Molecular detection
        if current_time - last_molecule_time >= molecule_interval:
            # Sync to CPU
            positions_cpu = cp.asnumpy(positions_gpu)
            velocities_cpu = cp.asnumpy(velocities_gpu)
            for i, p in enumerate(all_particles):
                p.position = positions_cpu[i]
                p.velocity = velocities_cpu[i]
            
            molecules = find_molecules(all_particles)
            molecule_counts = defaultdict(int)
            for molecule in molecules:
                pattern = identify_molecule(molecule)
                molecule_counts[pattern] += 1
            
            history_entry = {"time": current_time, **molecule_counts}
            molecule_history.append(history_entry)
            
            if molecule_counts:
                log_parts = [f"{pattern}: {count}" for pattern, count in sorted(molecule_counts.items())]
                print(f"üß™ Molecules detected: {', '.join(log_parts)}")
            else:
                print("üß™ No molecules detected (only isolated atoms)")
            
            last_molecule_time = current_time
    
    elapsed = time.time() - start_time
    print(f"\n‚úÖ Simulation complete! Ran {current_time:.1f}s simulation in {elapsed:.1f}s real time")
    print(f"   Speedup: {current_time / elapsed:.1f}x")
    
    # Free GPU memory
    mempool.free_all_blocks()
    
    return molecule_history

def detect_exponential_growth(molecule_history: List[Dict[str, int]], molecule_type: str) -> Tuple[bool, float]:
    """Detect if a molecule type shows exponential growth"""
    if len(molecule_history) < 5:
        return False, 0.0
    
    times = []
    counts = []
    for entry in molecule_history:
        times.append(entry["time"])
        counts.append(entry.get(molecule_type, 0))
    
    if all(c == 0 for c in counts):
        return False, 0.0
    
    times = np.array(times)
    counts = np.array(counts)
    mask = counts > 0
    if np.sum(mask) < 3:
        return False, 0.0
    
    times_fit = times[mask]
    counts_fit = counts[mask]
    log_counts = np.log(counts_fit + 1e-10)
    
    if len(times_fit) > 1:
        coeffs = np.polyfit(times_fit, log_counts, 1)
        growth_rate = coeffs[0]
        
        predicted = np.polyval(coeffs, times_fit)
        ss_res = np.sum((log_counts - predicted) ** 2)
        ss_tot = np.sum((log_counts - np.mean(log_counts)) ** 2)
        r_squared = 1 - (ss_res / (ss_tot + 1e-10))
        
        is_exponential = r_squared > 0.8 and growth_rate > 0.01
        return is_exponential, growth_rate
    
    return False, 0.0

def analyze_results(molecule_history: List[Dict[str, int]]):
    """Analyze results to find replicating molecules"""
    if not molecule_history:
        print("No molecule history to analyze")
        return
    
    all_types = set()
    for entry in molecule_history:
        all_types.update(entry.keys())
    all_types.discard("time")
    
    print("\nüìä Analyzing for self-replication...")
    print("=" * 60)
    
    replicating = []
    for molecule_type in sorted(all_types):
        is_exp, growth_rate = detect_exponential_growth(molecule_history, molecule_type)
        if is_exp:
            replicating.append((molecule_type, growth_rate))
            print(f"‚úÖ {molecule_type}: EXPONENTIAL GROWTH (rate: {growth_rate:.4f})")
        else:
            print(f"‚ùå {molecule_type}: No exponential growth")
    
    if replicating:
        print("\nüéâ SELF-REPLICATION DETECTED!")
        print(f"   Replicating molecules: {[m[0] for m in replicating]}")
    else:
        print("\n‚ö†Ô∏è  No self-replication detected")
        print("   Try different parameters or run longer simulation")

if __name__ == "__main__":
    # Run GPU simulation
    history = run_simulation_gpu(
        duration=600.0,
        time_acceleration=10  # 10x time acceleration (optimized for faster iterations)
    )
    
    # Analyze results
    analyze_results(history)







.
--- FILE: "C:\Users\15615\Documents\boolaka\python\spatial_hash_grid.py" --- 
"""
The "bucket" system. Solves lag before it happens.
"""

from typing import List, Dict, Any
import numpy as np

class SpatialHashGrid:
    """Spatial hash grid for efficient neighbor queries"""
    def __init__(self, cell_size: float):
        self.cell_size = cell_size
        self.buckets: Dict[str, List[Any]] = {}
    
    def clear(self):
        """Clear all buckets"""
        self.buckets = {}
    
    def insert(self, particle: Any):
        """Insert a particle into the grid"""
        cell_x = int(particle.position[0] / self.cell_size)
        cell_y = int(particle.position[1] / self.cell_size)
        key = f"{cell_x},{cell_y}"
        
        if key not in self.buckets:
            self.buckets[key] = []
        
        self.buckets[key].append(particle)
    
    def query(self, position: np.ndarray) -> List[Any]:
        """Query for particles near a position"""
        cell_x = int(position[0] / self.cell_size)
        cell_y = int(position[1] / self.cell_size)
        results = []
        
        # Check the cell and its 8 neighbors
        for dx in range(-1, 2):
            for dy in range(-1, 2):
                key = f"{cell_x + dx},{cell_y + dy}"
                bucket = self.buckets.get(key)
                if bucket:
                    results.extend(bucket)
        
        return results







.
--- FILE: "C:\Users\15615\Documents\boolaka\python\requirements.txt" --- 
numpy>=1.24.0
cupy-cuda12x>=12.0.0

.
--- FILE: "C:\Users\15615\Documents\boolaka\python\parameter_sweep_results.json" --- 
{
  "winners": [],
  "all_results": [
    {
      "params": {
        "sun_strength": 500,
        "planet_particles": 990,
        "atmosphere_particles": 0,
        "c_ratio": 70,
        "h_ratio": 0,
        "o_ratio": 30
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 500,
        "planet_particles": 693,
        "atmosphere_particles": 33,
        "c_ratio": 50,
        "h_ratio": 30,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 500,
        "planet_particles": 495,
        "atmosphere_particles": 55,
        "c_ratio": 30,
        "h_ratio": 50,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 500,
        "planet_particles": 594,
        "atmosphere_particles": 44,
        "c_ratio": 40,
        "h_ratio": 40,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 500,
        "planet_particles": 792,
        "atmosphere_particles": 22,
        "c_ratio": 60,
        "h_ratio": 20,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 1000,
        "planet_particles": 990,
        "atmosphere_particles": 0,
        "c_ratio": 70,
        "h_ratio": 0,
        "o_ratio": 30
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 1000,
        "planet_particles": 693,
        "atmosphere_particles": 33,
        "c_ratio": 50,
        "h_ratio": 30,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 1000,
        "planet_particles": 495,
        "atmosphere_particles": 55,
        "c_ratio": 30,
        "h_ratio": 50,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 1000,
        "planet_particles": 594,
        "atmosphere_particles": 44,
        "c_ratio": 40,
        "h_ratio": 40,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 1000,
        "planet_particles": 792,
        "atmosphere_particles": 22,
        "c_ratio": 60,
        "h_ratio": 20,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 2000,
        "planet_particles": 990,
        "atmosphere_particles": 0,
        "c_ratio": 70,
        "h_ratio": 0,
        "o_ratio": 30
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 2000,
        "planet_particles": 693,
        "atmosphere_particles": 33,
        "c_ratio": 50,
        "h_ratio": 30,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 2000,
        "planet_particles": 495,
        "atmosphere_particles": 55,
        "c_ratio": 30,
        "h_ratio": 50,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 2000,
        "planet_particles": 594,
        "atmosphere_particles": 44,
        "c_ratio": 40,
        "h_ratio": 40,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 2000,
        "planet_particles": 792,
        "atmosphere_particles": 22,
        "c_ratio": 60,
        "h_ratio": 20,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 5000,
        "planet_particles": 990,
        "atmosphere_particles": 0,
        "c_ratio": 70,
        "h_ratio": 0,
        "o_ratio": 30
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 5000,
        "planet_particles": 693,
        "atmosphere_particles": 33,
        "c_ratio": 50,
        "h_ratio": 30,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 5000,
        "planet_particles": 495,
        "atmosphere_particles": 55,
        "c_ratio": 30,
        "h_ratio": 50,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 5000,
        "planet_particles": 594,
        "atmosphere_particles": 44,
        "c_ratio": 40,
        "h_ratio": 40,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 5000,
        "planet_particles": 792,
        "atmosphere_particles": 22,
        "c_ratio": 60,
        "h_ratio": 20,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 10000,
        "planet_particles": 990,
        "atmosphere_particles": 0,
        "c_ratio": 70,
        "h_ratio": 0,
        "o_ratio": 30
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 10000,
        "planet_particles": 693,
        "atmosphere_particles": 33,
        "c_ratio": 50,
        "h_ratio": 30,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 10000,
        "planet_particles": 495,
        "atmosphere_particles": 55,
        "c_ratio": 30,
        "h_ratio": 50,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 10000,
        "planet_particles": 594,
        "atmosphere_particles": 44,
        "c_ratio": 40,
        "h_ratio": 40,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    },
    {
      "params": {
        "sun_strength": 10000,
        "planet_particles": 792,
        "atmosphere_particles": 22,
        "c_ratio": 60,
        "h_ratio": 20,
        "o_ratio": 20
      },
      "replicating": [],
      "success": false
    }
  ],
  "total_tests": 25,
  "total_time": 1529.5184390544891
}.
--- FILE: "C:\Users\15615\Documents\boolaka\python\README.md" --- 
# Python Simulation

Fast simulation ported from Roblox/Lua for detecting self-replication.

## Setup

```bash
pip install -r requirements.txt
```

**Note:** CuPy requires CUDA. For NVIDIA GPUs, install the appropriate version:
- CUDA 12.x: `cupy-cuda12x`
- CUDA 11.x: `cupy-cuda11x`

## Run

**CPU version (slower):**
```bash
python simulation.py
```

**GPU version (much faster, requires NVIDIA GPU):**
```bash
python simulation_gpu.py
```

## Configuration

Edit `config.py` to change:
- Particle counts
- Sun strength
- World size
- Physics constants

## Output

- Logs molecule counts every 5 seconds
- Analyzes for exponential growth at the end
- Reports which molecules (if any) are self-replicating

## Speed

Runs ~100-1000x faster than Roblox, depending on particle count.

.
--- FILE: "C:\Users\15615\Documents\boolaka\src\server\boot.server.luau" --- 
--!native
--!strict
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local Shared = ReplicatedStorage:WaitForChild("Shared")
local Config = require(Shared:WaitForChild("Config"))
local Matter = require(Shared:WaitForChild("Matter"))
local PhysicsKernel = require(Shared:WaitForChild("PhysicsKernel"))
local SpatialHashGrid = require(Shared:WaitForChild("SpatialHashGrid"))

type Particle = Matter.Particle

-- 1. CREATE THE UNIVERSE
print("üåå Creating Universe...")

local AllParticles = {}
local Grid = SpatialHashGrid.new(Config.WORLD.GRID_CELL_SIZE)

-- 2. SEED THE "PLANET" (The Primordial Soup)
print("üåç Seeding Planet...")

for i = 1, Config.SEED.PLANET_PARTICLES do
	-- Spawn in a dense clump at the bottom
	local pos = Vector2.new(
		math.random(0, Config.WORLD.WIDTH),
		math.random(0, Config.WORLD.HEIGHT / 4) -- Only in bottom 25%
	)
	
	-- 70% Carbon, 30% Oxygen
	local pType = if math.random() < 0.7 then "CARBON" else "OXYGEN"
	local p = Matter.create(pType, pos)
	table.insert(AllParticles, p)
end

-- 3. SEED THE "ATMOSPHERE" (The Fuel)
print("üí® Seeding Atmosphere...")

for i = 1, Config.SEED.ATMOSPHERE_PARTICLES do
	-- Spawn in a thin gas at the top
	local pos = Vector2.new(
		math.random(0, Config.WORLD.WIDTH),
		math.random(Config.WORLD.HEIGHT / 2, Config.WORLD.HEIGHT) -- Only in top 50%
	)
	
	local p = Matter.create("HYDROGEN", pos)
	table.insert(AllParticles, p)
end

print("üî• IGNITION. Starting Physics Loop...")

-- 4. MOLECULAR DETECTION FUNCTIONS
-- Find all molecules (connected components via bonds)
local function findMolecules(particles: {Particle}): {{Particle}}
	local molecules = {}
	local visited = {}
	
	-- DFS to find all particles in a molecule
	local function dfs(particle: Particle, molecule: {Particle})
		if visited[particle] then return end
		visited[particle] = true
		table.insert(molecule, particle)
		
		-- Visit all bonded particles
		for _, bonded in particle.bonds do
			dfs(bonded, molecule)
		end
	end
	
	-- Find all molecules
	for _, particle in particles do
		if not visited[particle] and #particle.bonds > 0 then
			-- Only count particles that have bonds (molecules, not isolated atoms)
			local molecule = {}
			dfs(particle, molecule)
			if #molecule > 1 then -- Only molecules with 2+ atoms
				table.insert(molecules, molecule)
			end
		end
	end
	
	return molecules
end

-- Identify molecular patterns
local function identifyMolecule(molecule: {Particle}): string
	local carbonCount = 0
	local hydrogenCount = 0
	local oxygenCount = 0
	
	for _, particle in molecule do
		if particle.particleType == "CARBON" then
			carbonCount = carbonCount + 1
		elseif particle.particleType == "HYDROGEN" then
			hydrogenCount = hydrogenCount + 1
		elseif particle.particleType == "OXYGEN" then
			oxygenCount = oxygenCount + 1
		end
	end
	
	-- Match to known patterns
	if carbonCount == 1 and hydrogenCount == 4 then
		return "CH4"
	elseif carbonCount == 1 and oxygenCount == 2 then
		return "CO2"
	elseif carbonCount == 1 and hydrogenCount == 2 and oxygenCount == 1 then
		return "H2CO"
	elseif hydrogenCount == 2 and oxygenCount == 1 then
		return "H2O"
	elseif hydrogenCount == 2 then
		return "H2"
	elseif oxygenCount == 2 then
		return "O2"
	elseif carbonCount == 1 and oxygenCount == 1 then
		return "CO"
	elseif carbonCount > 0 or hydrogenCount > 0 or oxygenCount > 0 then
		-- Unknown pattern, return formula
		local formula = ""
		if carbonCount > 0 then formula = formula .. "C" .. (carbonCount > 1 and tostring(carbonCount) or "") end
		if hydrogenCount > 0 then formula = formula .. "H" .. (hydrogenCount > 1 and tostring(hydrogenCount) or "") end
		if oxygenCount > 0 then formula = formula .. "O" .. (oxygenCount > 1 and tostring(oxygenCount) or "") end
		return formula
	else
		return "UNKNOWN"
	end
end

-- 5. THE MAIN LOOP (Heartbeat of God)
local frameCount = 0
RunService.Heartbeat:Connect(function(dt)
	frameCount = frameCount + 1
	
	-- DEBUG: Confirm loop is running
	if frameCount == 1 then
		print("‚úÖ Physics loop started (frame 1)")
	end
	
	-- Cap dt to prevent physics explosions from lag spikes
	if dt > 0.1 then dt = 0.1 end
	
	-- This must be done every frame
	Grid:Clear()
	
	-- == INSERT PHASE ==
	-- Put all particles into their new buckets
	for _, p in AllParticles do
		Grid:Insert(p)
	end
	
	-- == PHYSICS PHASE (Now Singular) ==
	local processedCount = 0
	for _, p in AllParticles do
		-- 1. Find all neighbors
		local neighbors = Grid:Query(p.position)
		
		-- 2. Interact with neighbors and maintain bonds
		local neighborCount = 0
		for _, neighbor in neighbors do
			if p == neighbor then continue end -- Don't check against self
			if neighborCount >= 20 then break end -- Limit neighbors per particle
			
			-- Apply the Lennard-Jones force (pure physics)
			PhysicsKernel.ApplyAtomicForce(p, neighbor)
			
			-- Track bonds (just metadata - bonds form from physics above)
			local diff = Vector2.new(
				neighbor.position.X - p.position.X,
				neighbor.position.Y - p.position.Y
			)
			local distance = diff.Magnitude
			
			-- Calculate equilibrium distance (average sigma)
			local equilibriumDist = (p.sigma + neighbor.sigma) / 2
			local bondThreshold = equilibriumDist * 1.2 -- Allow 20% tolerance for movement
			
			-- Check relative velocity (stable if moving together, not apart)
			local relativeVel = Vector2.new(
				neighbor.velocity.X - p.velocity.X,
				neighbor.velocity.Y - p.velocity.Y
			)
			local relativeSpeed = relativeVel.Magnitude
			
			-- Bond if: within equilibrium distance AND stable (low relative velocity)
			if distance <= bondThreshold and relativeSpeed < 1.5 then
				if not Matter.isBonded(p, neighbor) then
					Matter.addBond(p, neighbor)
				end
			else
				-- Unbond if: too far apart OR moving apart too fast
				if distance > bondThreshold * 1.5 or relativeSpeed > 3.0 then
					if Matter.isBonded(p, neighbor) then
						Matter.removeBond(p, neighbor)
					end
				end
			end
			
			neighborCount = neighborCount + 1
		end
		
		-- 3. Apply universal laws
		PhysicsKernel.Move(p, dt)
		
		-- 5. Check boundaries (simple "box" collision)
		if p.position.X < 0 or p.position.X > Config.WORLD.WIDTH then
			p.velocity = Vector2.new(-p.velocity.X, p.velocity.Y) -- Bounce off walls
			p.position = Vector2.new(math.clamp(p.position.X, 0, Config.WORLD.WIDTH), p.position.Y)
		end
		if p.position.Y < 0 or p.position.Y > Config.WORLD.HEIGHT then
			p.velocity = Vector2.new(p.velocity.X, -p.velocity.Y) -- Bounce off floor/ceiling
			p.position = Vector2.new(p.position.X, math.clamp(p.position.Y, 0, Config.WORLD.HEIGHT))
		end
		
		-- Yield every 1000 particles to prevent timeout
		processedCount = processedCount + 1
		if processedCount % 1000 == 0 then
			task.wait()
		end
	end
	
	-- == LOGGING PHASE (Count Actual Bonds) ==
	-- Count bonds directly from the bonds lists (no inference, no sampling)
	if frameCount % 60 == 0 then -- ~1 second at 60fps
		local totalBonds = 0
		
		-- Count all bonds (each bond is stored in both particles, so divide by 2)
		for _, p in AllParticles do
			totalBonds = totalBonds + #p.bonds
		end
		
		-- Each bond is counted twice (once per particle), so divide by 2
		local actualBonds = totalBonds / 2
		
		print(string.format("‚è±Ô∏è  Time: %.1fs | Particles: %d | Bonds: %.0f", 
			frameCount / 60, #AllParticles, actualBonds))
	end
	
	-- == MOLECULAR DETECTION PHASE ==
	-- Detect molecular patterns every 5 seconds
	if frameCount % 300 == 0 then -- ~5 seconds at 60fps
		local molecules = findMolecules(AllParticles)
		
		-- Count molecules by type
		local moleculeCounts = {}
		for _, molecule in molecules do
			local pattern = identifyMolecule(molecule)
			moleculeCounts[pattern] = (moleculeCounts[pattern] or 0) + 1
		end
		
		-- Log results
		if next(moleculeCounts) then
			local logParts = {}
			for pattern, count in pairs(moleculeCounts) do
				table.insert(logParts, string.format("%s: %d", pattern, count))
			end
			table.sort(logParts)
			print(string.format("üß™ Molecules detected: %s", table.concat(logParts, ", ")))
		else
			print("üß™ No molecules detected (only isolated atoms)")
		end
	end
end)

.
--- FILE: "C:\Users\15615\Documents\boolaka\src\shared\Config.luau" --- 
--!native
--!strict
-- This file holds the "Physics DNA" of our universe.
-- We will evolve these numbers.

local Config = {
	
	-- Matter Constants
	CHEMISTRY = {
		BOND_DISTANCE = 5,  -- How close particles must be to stick
	},
	
	-- Physics Constants
	PHYSICS = {
		GRAVITY = Vector2.new(0, -9.8), -- A constant downward pull
	},
	
	-- World Constants
	WORLD = {
		GRID_CELL_SIZE = 10,  -- The size of our lag-stopping "buckets"
		WIDTH = 500,          -- Size of the 2D "box"
		HEIGHT = 1000,        -- Size of the 2D "box"
	},
	
	-- Sun Constants (Radiative Energy Source)
	-- Real physics: Inverse Square Law (energy = constant / distance¬≤)
	-- Solar constant: ~1361 W/m¬≤ at Earth's distance (scaled for simulation)
	SUN = {
		POSITION = Vector2.new(250, 1000),  -- Position of energy source (top center)
		STRENGTH = 2000.0,                  -- Radiative power (scaled for simulation units)
	},
	
	-- Simulation Constants
	SEED = {
		PLANET_PARTICLES = 10000,    -- DOWN from 90,000 for testing
		ATMOSPHERE_PARTICLES = 1000, -- DOWN from 10,000 for testing
	},
}

return Config

.
--- FILE: "C:\Users\15615\Documents\boolaka\src\shared\Matter.luau" --- 
--!native
--!strict
local Config = require(script.Parent.Config)

-- This is the "atom" of our universe.
-- It's a pure data structure.

export type Particle = {
	-- Physics State
	position: Vector2,
	velocity: Vector2,
	mass: number,     -- Mass (for gravity and kinetic energy)
	
	-- Chemical State
	particleType: string, -- "CARBON", "HYDROGEN", "OXYGEN"
	
	-- Lennard-Jones Parameters (Real atomic properties)
	epsilon: number,  -- Bond strength (well depth)
	sigma: number,    -- Atomic radius (equilibrium distance)
	
	-- Bond Tracking (just metadata - bonds form from physics)
	bonds: {Particle}, -- List of particles this particle is bonded to
}

-- Real atomic properties (Lennard-Jones parameters + mass)
-- Based on measured values from molecular dynamics simulations
local ATOMIC_PROPERTIES = {
	CARBON = {
		epsilon = 0.105,  -- kcal/mol (bond strength)
		sigma = 3.40,     -- Angstroms (atomic radius)
		mass = 12.0,       -- Atomic mass units (Carbon-12)
	},
	HYDROGEN = {
		epsilon = 0.022,  -- Weakest bonds
		sigma = 2.65,     -- Smallest atom
		mass = 1.0,        -- Atomic mass units (Hydrogen-1)
	},
	OXYGEN = {
		epsilon = 0.120,  -- Strong bonds
		sigma = 3.12,     -- Medium size
		mass = 16.0,       -- Atomic mass units (Oxygen-16)
	},
}

-- Factory for making new particles
local function create(pType: string, pos: Vector2): Particle
	local props = ATOMIC_PROPERTIES[pType] or ATOMIC_PROPERTIES.CARBON
	
	local self: Particle = {
		position = pos,
		velocity = Vector2.new(0, 0), -- Start still
		mass = props.mass,
		
		particleType = pType,
		epsilon = props.epsilon,
		sigma = props.sigma,
		
		bonds = {}, -- Start with no bonds
	}
	
	return self
end

-- Helper function to check if particle A is bonded to particle B
local function isBonded(particle: Particle, other: Particle): boolean
	for _, bonded in particle.bonds do
		if bonded == other then
			return true
		end
	end
	return false
end

-- Helper function to add a bond (both directions)
local function addBond(particleA: Particle, particleB: Particle)
	if not isBonded(particleA, particleB) then
		table.insert(particleA.bonds, particleB)
		table.insert(particleB.bonds, particleA)
	end
end

-- Helper function to remove a bond (both directions)
local function removeBond(particleA: Particle, particleB: Particle)
	-- Remove B from A's bonds
	for i = #particleA.bonds, 1, -1 do
		if particleA.bonds[i] == particleB then
			table.remove(particleA.bonds, i)
			break
		end
	end
	-- Remove A from B's bonds
	for i = #particleB.bonds, 1, -1 do
		if particleB.bonds[i] == particleA then
			table.remove(particleB.bonds, i)
			break
		end
	end
end

return {
	create = create,
	isBonded = isBonded,
	addBond = addBond,
	removeBond = removeBond,
}

echo ..
--- FILE: "C:\Users\15615\Documents\boolaka\src\shared\PhysicsKernel.luau" --- 
--!native
--!strict
-- THE SINGULAR LAW: Lennard-Jones Potential
-- This ONE function replaces Collide(), Bond(), and ApplyBondConstraints()
-- It models the actual electromagnetic force between atoms

local Config = require(script.Parent.Config)
local Matter = require(script.Parent.Matter)

type Particle = Matter.Particle

local PhysicsKernel = {}

-- ###############################################################
-- ## THE SINGULAR LAW: ApplyAtomicForce
-- ###############################################################
-- This ONE function REPLACES Collide(), Bond(), and ApplyBondConstraints().
-- It calculates the REAL electromagnetic force between two particles.

function PhysicsKernel.ApplyAtomicForce(particleA: Particle, particleB: Particle)
	
	-- 1. Get the vector and distance between them
	local diff = Vector2.new(
		particleB.position.X - particleA.position.X,
		particleB.position.Y - particleA.position.Y
	)
	local distance = diff.Magnitude
	
	-- Optimization: If they are too far apart, don't bother.
	-- This "cutoff" distance saves 99% of our CPU.
	if distance > Config.CHEMISTRY.BOND_DISTANCE or distance == 0 then
		return
	end
	
	-- ### THE LENNARD-JONES MATH (The God Formula) ###
	-- Use Lorentz-Berthelot mixing rules for different atom types
	-- This is how real molecular dynamics handles different atoms
	local epsilon = math.sqrt(particleA.epsilon * particleB.epsilon)  -- Geometric mean
	local sigma = (particleA.sigma + particleB.sigma) / 2  -- Arithmetic mean
	
	-- 1. (SIGMA / distance)^6  -> This is the ATTRACTION force (pulls them together)
	-- 2. (SIGMA / distance)^12 -> This is the REPULSION force (shoves them apart)
	local term = sigma / distance
	
	-- We calculate the attraction (to the 6th power)
	local attraction = math.pow(term, 6)
	
	-- We calculate the repulsion (to the 12th power)
	-- Because it's to the 12th, it's MUCH stronger at close range.
	local repulsion = math.pow(term, 12)
	
	-- The total force = (Repulsion - Attraction)
	-- We multiply by 4 * Epsilon to get the right strength
	local forceMagnitude = 4 * epsilon * (repulsion - attraction)
	
	-- ### END OF MATH ###
	
	-- Now we apply that force to both particles
	-- We get the direction (diff.Unit) and multiply by the strength (forceMagnitude)
	local normal = diff.Unit
	local forceVector = Vector2.new(
		forceMagnitude * normal.X,
		forceMagnitude * normal.Y
	)
	
	-- We push/pull both particles based on this one, true force.
	-- Newton's 3rd law: equal and opposite forces
	particleA.velocity = Vector2.new(
		particleA.velocity.X - forceVector.X,
		particleA.velocity.Y - forceVector.Y
	)
	particleB.velocity = Vector2.new(
		particleB.velocity.X + forceVector.X,
		particleB.velocity.Y + forceVector.Y
	)
end

-- LAW 2: MOVEMENT (Gravity + Radiative Heating)
function PhysicsKernel.Move(particle: Particle, dt: number)
	
	-- Apply gravity (constant pull down)
	particle.velocity = Vector2.new(
		particle.velocity.X + Config.PHYSICS.GRAVITY.X * dt,
		particle.velocity.Y + Config.PHYSICS.GRAVITY.Y * dt
	)
	
	-- Apply radiative heating (Inverse Square Law)
	-- Real physics: Energy received = SUN_STRENGTH / (distance¬≤)
	local sunDiff = Vector2.new(
		Config.SUN.POSITION.X - particle.position.X,
		Config.SUN.POSITION.Y - particle.position.Y
	)
	local sunDistance = sunDiff.Magnitude
	
	-- Prevent singularity at distance = 0
	if sunDistance > 0.1 then
		-- Inverse square law: energy = strength / distance¬≤
		local energyReceived = Config.SUN.STRENGTH / (sunDistance * sunDistance)
		
		-- Convert energy to kinetic energy: KE = 0.5 * m * v¬≤
		-- So: v = sqrt(2 * KE / m)
		-- We add this as a velocity impulse in the direction away from the sun
		local velocityImpulse = math.sqrt(2 * energyReceived / particle.mass) * dt
		local sunDirection = sunDiff.Unit
		
		particle.velocity = Vector2.new(
			particle.velocity.X + sunDirection.X * velocityImpulse,
			particle.velocity.Y + sunDirection.Y * velocityImpulse
		)
	end
	
	-- Update position
	particle.position = Vector2.new(
		particle.position.X + particle.velocity.X * dt,
		particle.position.Y + particle.velocity.Y * dt
	)
end

return PhysicsKernel
echo ..
--- FILE: "C:\Users\15615\Documents\boolaka\src\shared\SpatialHashGrid.luau" --- 
--!native
--!strict
-- The "bucket" system. Solves lag before it happens.

export type SpatialHashGrid = {
	cellSize: number,
	buckets: {[string]: {any}},
	
	new: (cellSize: number) -> SpatialHashGrid,
	Clear: (self: SpatialHashGrid) -> (),
	Insert: (self: SpatialHashGrid, particle: any) -> (),
	Query: (self: SpatialHashGrid, position: Vector2) -> {any},
}

local function new(cellSize: number): SpatialHashGrid
	local self: SpatialHashGrid = {
		cellSize = cellSize,
		buckets = {},
		
		new = nil :: any,
		Clear = nil :: any,
		Insert = nil :: any,
		Query = nil :: any,
	}
	
	function self:Clear()
		self.buckets = {}
	end
	
	function self:Insert(particle: any)
		local cellX = math.floor(particle.position.X / self.cellSize)
		local cellY = math.floor(particle.position.Y / self.cellSize)
		local key = tostring(cellX) .. "," .. tostring(cellY)
		
		if not self.buckets[key] then
			self.buckets[key] = {}
		end
		
		table.insert(self.buckets[key], particle)
	end
	
	function self:Query(position: Vector2): {any}
		local cellX = math.floor(position.X / self.cellSize)
		local cellY = math.floor(position.Y / self.cellSize)
		local results = {}
		
		-- Check the cell and its 8 neighbors
		for dx = -1, 1 do
			for dy = -1, 1 do
				local key = tostring(cellX + dx) .. "," .. tostring(cellY + dy)
				local bucket = self.buckets[key]
				if bucket then
					for _, particle in bucket do
						table.insert(results, particle)
					end
				end
			end
		end
		
		return results
	end
	
	return self
end

return {
	new = new,
}







echo ..
